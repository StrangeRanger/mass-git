#!/usr/bin/env bash
#
# Fetch or pull one or more git repositories at a specified location on your system.
#
# License: MIT License
#          Copyright (c) 2021-2024 Hunter T. (StrangeRanger)
#
########################################################################################
####[ Variables ]#######################################################################


## ANSI color codes.
C_GREEN="$(printf '\033[0;32m')"
C_BLUE="$(printf '\033[0;34m')"
C_CYAN="$(printf '\033[0;36m')"
C_RED="$(printf '\033[1;31m')"
C_NC="$(printf '\033[0m')"

## Shorthanded variables for colorized output.
C_INVALID_INPUT="${C_RED}Invalid input:${C_NC} "
C_SUCCESS="${C_GREEN}==>${C_NC} "
C_ERROR="${C_RED}ERROR:${C_NC} "
C_INFO="${C_BLUE}==>${C_NC} "
C_NOTE="${C_CYAN}==>${C_NC} "

## Program information.
C_VERSION="v1.2.0"

## Set constants as readonly.
readonly C_GREEN C_BLUE C_CYAN C_RED C_NC
readonly C_INVALID_INPUT C_SUCCESS C_ERROR C_INFO C_NOTE
readonly C_VERSION

## Other variables.
maxdepth="-maxdepth 2"  # Peform recursive searches with a maximum depth of 2.
provided_path=false  # Validates that a path was provided.
git_repos=()  # List of paths to existing repositories on the system.
git_action="pull"
git_action_prog="Pulling"


####[ Functions ]#######################################################################


####
# Display the usage message for the program.
usage() {
    echo "Fetch or pull one or more git repositories at a specified location on your system."
    echo ""
    echo "Usage: ${0##*/} [-r] [-f] [-d] -p <path>"
    echo "       ${0##*/} -h"
    echo "       ${0##*/} -v"
    echo ""
    echo "Options:"
    echo "  -h, --help       : Displays this help message."
    echo "  -p, --path       : Path to perform mass git pull/fetch on."
    echo "  -r, --recursive  : Recursively locate git repositories."
    echo "  -f, --fetch      : Fetch instead of pull from git repository."
    echo "  -d, --dry-run    : Show what would be done, without making any changes."
    echo "  -v, --version    : Display program version number."
}


####[ Options ]#########################################################################


# If no arguments are provided...
if [[ $# -eq 0 ]]; then
    usage
    exit 0
fi

# While there are still arguments to traverse...
while [[ -n $1 ]]; do
    case "$1" in
        "-h"|"--help")
            usage
            exit 0
            ;;
        "-p"|"--path")
            shift

            if hash realpath; then
                path="$(realpath "$1" 2>/dev/null || echo "BAD MAGIC")"
            else
                # This solution was found at the following link:
                # https://stackoverflow.com/questions/4175264/how-to-retrieve-absolute-path-given-relative/31605674#31605674
                path="$(cd "${1%/*}" || exit; pwd)/${1##*/}"
            fi
            provided_path=true
            ;;
        "-r"|"--recursive")
            unset maxdepth  # Remove the maxium depth of recursion.
            ;;
        "-f"|"--fetch")
            git_action="fetch"
            git_action_prog="Fetching"
            ;;
        "-d"|"--dry-run")
            dry_run="--dry-run"
            ;;
        "-v"|"--version")
            echo "Mass Git $C_VERSION"
            exit 0
            ;;
        *)
            echo "${C_RED}Invalid option:${C_NC} $1" >&2
            exit 1
            ;;
    esac
    shift
done

## Check if the provided path is a valid directory.
if "$provided_path"; then
    if [[ -f $path ]]; then
        echo "${C_INVALID_INPUT}File was provided when a directory was expected" >&2
        exit 1
    elif [[ ! -d $path ]]; then
        echo "${C_INVALID_INPUT}Directory does not exist" >&2
        exit 1
    fi
else
    echo "${C_INVALID_INPUT}Missing required argument '-p <path>'"
    exit 1
fi


####[ Main ]############################################################################


## Store the location of all local repositories found.
# shellcheck disable=SC2086
while read -r -d $'\0'; do
    git_repos+=("${REPLY/%.git/}")
done < <(find "$path" $maxdepth -type d -name ".git" -prune -print0)

# If no local repositories were found...
# NOTE: Leave $git_repos as is. It's fine that only the first index of the array is
#       provided, as all I'm are trying to do is confirm whether or not a git
#       initialized directory was located.
# shellcheck disable=SC2128
if [[ -z $git_repos ]]; then
    echo "${C_ERROR}No git initialized directory could be found"
    exit 1
fi

[[ $dry_run = "--dry-run" ]] && echo "${C_NOTE}Performing a dry-run..."

for repo_path in "${git_repos[@]}"; do
    echo "${C_INFO}Changing directories to '$repo_path'..."
    cd "$repo_path" || {
        echo "${C_ERROR}Failed to change directories"
        exit 1
    }
    repo_name="$(git config --get remote.origin.url)"

    echo "${C_INFO}$git_action_prog changes from '$repo_name'..."
    # shellcheck disable=SC2086
    git "$git_action" $dry_run \
        || echo "${C_ERROR}Failed to $git_action changes from '$repo_name'"
done

echo "${C_SUCCESS}Done"

